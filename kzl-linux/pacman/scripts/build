#!/usr/bin/bash
#
# build.sh
#

script_name="$(basename "${0}")"
stage=1
build_dir=/tmp
repo=kzl
log_dir=~/makepkg/log
repo_dir=/home/.repository/$repo
build_only_updated=0
no_install=0
no_clean=0
no_check=0

# preparation
kzl_stage0_pkgs=(
)

# toolchain
kzl_stage1_pkgs=(
)

_toolchain=(
    ## glibc
    linux-api-headers tzdata
    glibc
    ## toolchain
    zlib zstd
    binutils
    gmp isl mpfr mpc
    gcc
)

# base
kzl_stage2_pkgs=(
    ### base
    ## filesystem
    # iana-etc filesystem
    ## toolchain
    # ${_toolchain[@]}
    # ${_toolchain[@]}
    # libtool
    ## bash
    # ncurses readline
    # bash bash-completion
    ## perl
    # libxcrypt db gdbm
    # perl
    ## compression tools
    # bzip2
    # pcre2 less gzip
    ## GNU tools/lib
    # libsigsegv gawk
    # texinfo
    # m4
    # help2man flex
    ## openssl
    # openssl
    ## ca-certificates
    # libtasn1 libffi p11-kit
    # ca-certificates

    ## pam
    # swig libcap-ng audit
    cyrus-sasl

    ## coreutils
    # attr acl
    # coreutils
    ## pacman
    # pacman
    ## base
    # base
)

kzl_stage3_pkgs=(
)

# functions

# Show an INFO message
# $1: message string
info() {
    local _msg="$1"
    printf '[%s] INFO: %s\n' "$script_name" "$_msg"
}

# Show a WARNING message
# $1: message string
warning() {
    local _msg="$1"
    printf '[%s] WARNING: %s\n' "$script_name" "$_msg" >&2
}

# Show an ERROR message then exit with status
# $1: message string
# $2: exit code number (with 0 does not exit)
error() {
    local _msg="$1"
    local _error="$2"
    printf '[%s] ERROR: %s\n' "$script_name" "$_msg" >&2
    if [ "$_error" -gt 0 ]; then
        exit "$_error"
    fi
}

prepare() {
    info "Removing pacman cache and database..."
    (yes yes || :) | sudo pacman -Scc > /dev/null 2>&1

    if [ ! -f /home/.repository/$repo/$repo.db ]; then
        info "Creating empty repo \"$repo\"..."
        updaterepo -t $repo > /dev/null 2>&1
    fi
    info "Synchronizing package databases..."
    (yes yes || :) | sudo pacman -Syy > /dev/null 2>&1

    if [ -d "$log_dir" ]; then
        info "Creating log directory..."
        mkdir -p "$log_dir"
    fi
}

get_pkgbase() {
    local _pkgbase
    case $1 in
        device-mapper)
            _pkgbase=lvm2
            ;;
        *)
            _pkgbase=$1
            ;;
    esac
    echo "$_pkgbase"
}

build() {
    local _pkgbase
    local _pkgname
    local _updated
    local _clean
    local _no_check
    local _log

    _pkgname=$1
    _pkgbase=$(get_pkgbase $_pkgname)
    _log="$log_dir"/$_pkgbase.stage$stage.log

    # remove existing log
    if [ -f $_log ]; then
        rm $_log
    fi

    cd $ROOTDIR/pkgbuilds/$repo/$_pkgbase

    # update pkgbuild
    info "Updating PKGBUILD..."
    _updated=0
    updatepkg >> $_log 2>&1 || _updated=$?

    if [ "$_updated" -ge 2 ]; then
        error "Cannot update the PKGBUILD." 4
    elif [ "$_updated" -eq 1 ]; then
        info "Package \"$_pkgbase\" is updated."
    fi

    if [ "$build_only_updated" -gt 0 -a "$_updated" -eq 0 ]; then
        info "Package \"$_pkgbase\" is already the latest version, will not build (-u, --build-only-updated)."
    else
        info "Building package..."

        _no_check=''
        if [ "$no_check" -gt 0 ]; then
            _no_check='--nocheck'
        fi
        _clean=''
        if [ "$no_clean" -le 0 ]; then
            _clean='--clean'
        fi
        makepkg -sCf  $_clean $_no_check --noconfirm >> $_log 2>&1

        info "Updating repo..."
        updaterepo -t $repo >> $_log 2>&1
    fi

    if [ "$no_install" -le 0 ]; then
        info "Installing package..."
        # (yes yes || :) | sudo pacman -Sddy --overwrite "*" $_pkgname --config ${pacman_conf}
        (yes yes || :) | sudo pacman -Sddy --overwrite "*" $_pkgname >> $_log 2>&1
    fi
}

usage() {
    local _usage="
build (kzl-linux)

build will build packages from scratch.

Usage: lfs-build [options]

    -h, --help                  display this help message and exit
    -r, --repo                  target repository (kzl, testing, ...)
    -s, --stage                 stage (0, 1(default), 2, 3)
    -n, --no-install            do not install the package after building
    -u, --build-only-updated    build the package only if the PKGBUILD is updated
    --no-clean                  skip cleaning up work files after build
    --no-check                  do not run the check() function in the PKGBUILD
    -v, --version               display version information and exit
"
    echo "$_usage"
}

################################################################

set -e
set -o pipefail
set -u
# set -x

umask 0022

while [ $# -gt 0 ]; do
    case "$1" in
    -h|--help)
        usage
        exit 0
        ;;
    -r|--repo)
        shift
        repo="$1"
        ;;
    -s|--stage)
        shift
        stage="$1"
        ;;
    -n|--no-install)
        no_install=1
        ;;
    -u|--build-only-updated)
        build_only_updated=1
        ;;
    --no-clean)
        no_clean=1
        ;;
    --no-check)
        no_check=1
        ;;
    *)
        usage
        error "Unknown option: \"$1\"" 1
        ;;
    esac
    shift
done

case $repo in
    kzl)
        case $stage in
        0)
            updaterepo --clear -t $repo
            pkgs=${kzl_stage0_pkgs[@]}
            ;;
        1)
            pkgs=${kzl_stage1_pkgs[@]}
            ;;
        2)
            echo -e "\033[1;33mBuilding stage 2\033[0m"
            pkgs=${kzl_stage2_pkgs[@]}
            ;;
        3)
            pkgs=${kzl_stage3_pkgs[@]}
            ;;
        *)
            error "Unknown stage \"$stage\"" 2
            ;;
        esac
        ;;
    *)
        error "Unknown repo name \"$repo\"" 3
        ;;
esac

start_time=$(date +%s)

prepare

for p in ${pkgs[@]}; do
    pkg_start_time=$(date +%s)
    echo -e "\e[1;31mBuilding $p ...\e[0m"
    build $p
    pkg_end_time=$(date +%s)
    pkg_total_time=$((pkg_end_time-pkg_start_time))
    echo -e "\e[1;32m$p: $(date -d@$pkg_total_time -u +%H:%M:%S)\e[0m"
done

end_time=$(date +%s)
total_time=$((end_time-start_time))

echo -e "\e[1;30m"
echo -e "****************************************************************"
echo -e "                Execution time Information                "
echo -e "****************************************************************"
echo -e "[$script_name]: End time - $(date)"
echo -e "[$script_name]: Total time - $(date -d@$total_time -u +%H:%M:%S)"
echo -e "\e[0m"
